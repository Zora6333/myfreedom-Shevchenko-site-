Задание 1

По данному url расположена задача:

*https://jsonplaceholder.typicode.com/todos/1*

В html предусмотреть <div></div>Достать с сервера заголовок задачи и отобразить его в div.

fetch('https://jsonplaceholder.typicode.com/todos/1')
.then(response => response.json())
.then(data => {
    const taskTitle = data.title;
    document.getElementById('task-title').textContent = taskTitle;
});


Задание 2

Запросом на сервер по url *https://jsonplaceholder.typicode.com/todos* достать задачи.

Отобразить первые 20 задач списком ul на странице. Содержимое каждого li - поле title объекта задачи.

fetch('https://jsonplaceholder.typicode.com/todos')
    .then(response => response.json())
    .then(data => {
        const taskList = document.getElementById('task-list');
        const tasks = data.slice(0, 20); // получаем первые 20 задач

        // создаем элементы списка и добавляем их в ul
        tasks.forEach(task => {
            const taskItem = document.createElement('li');
            taskItem.textContent = task.title;
            taskList.appendChild(taskItem);
        });
    });

    Задание 4

Отобразить на странице 10 первых комментариев с сервера *https://jsonplaceholder.typicode.com/comments*

Оформить тегами как в [ПРИМЕРЕ](https://ucarecdn.com/f9cf39fd-9f6d-409f-8dd4-51e416480bdc/ScreenshotatNov30170836.png).

Порядок работы:

1) записать в переменную блок для отрисовки результата.

2) описать функцию отрисовки результата (напр. addInfo). Функция принимает 3 параметра - тег, содержимое и название класса для CSS. Она создает тег, наполняет его текстом, добавляет класс и помещает в блок на страницу.

3) создать http-запрос и получить результат в виде массива объектов (через JSON.parse). Записать этот результат в переменную, т.к. с ним будем дальше работать.

4) внутри функции .onload:

- обойти через цикл первые 10 элементов массива

- вызвать функцию addInfo 3 раза: для добавления на страницу имени, имейла и комментария.

5) прописать CSS для классов.

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./task 16.3.css">
  <script src="./task 16.3.js" defer></script>
  <title>JSON Placeholder comments</title>
</head>
<body>
  <div id="result"></div>
</body>
</html>


//CSS//
 .comment {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ccc;
    }
    .name {
      font-weight: bold;
    }
    .email {
      color: #999;
    }
    .body {
      margin-top: 10px;
    }

    //JS//

    const result = document.getElementById('result');

function addInfo(tag, content, className) {
  const element = document.createElement(tag);
  element.textContent = content;
  element.classList.add(className);
  result.appendChild(element);
}

const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://jsonplaceholder.typicode.com/comments');
xhr.onload = function() {
  const comments = JSON.parse(xhr.response).slice(0, 10);
  for (const comment of comments) {
    addInfo('div', '', 'comment');
    addInfo('div', comment.name, 'name');
    addInfo('div', comment.email, 'email');
    addInfo('div', comment.body, 'body');
  }
}
xhr.send();

Задание 5

Создать собственный погодный виджет на основе данных с сервера погоды.

Оформить, как в примере: [ЗДЕСЬ](https://ucarecdn.com/f15529fb-d05d-47bd-b617-c517db0611f2/weather2.png).

Документация: [https://openweathermap.org/api...](https://openweathermap.org/api/hourly-forecast)

*Порядок работы:*

1) Проверить, работает ли API-ключ, данный в примере. Для этого открыть url [https://api.openweathermap.org...](https://api.openweathermap.org/data/2.5/forecast?q=Minsk&appid=a94d0a5ac08570add4b47b8da933f247)

Если данные отображаются - можно не получать свой ключ, иначе см. п. 1.1.

1.1. Зарегистрироваться и получить собственный API-ключ на сайте [https://home.openweathermap.or...](https://home.openweathermap.org/)

2) Создать html-css разметку под данные.

- общий блок для виджета, внутри него два блока - для текущей погоды и для прогноза (пример см. [ЗДЕСЬ](https://ucarecdn.com/477e6959-b37e-4555-a81c-3b707858b199/layout.png))

- внутри нижней части виджета через js будут добавляться строки по дням - это дивы, им нужно сразу прописать стили (flex-распределение вставляемых элементов, нижняя граница).

3) Написать JS с HTTP-запросом на url.

- кастомизировать url запроса: указать нужный город, добавить в url параметр отображения градусов по Цельсию (см. на странице документации раздел *Units of measurement*)

4) добавить информацию из ответа в виджет на страницу.

- в верхней части виджета отобразить город и дату (из полученного JSON-объекта).

Возможно, текущую дату проще получить из встроенной функции Date, примеры работы с ней [ЗДЕСЬ](https://itchief.ru/javascript/date).

- из JSON-объекта "достать" текущую погоду (.list[0]) - первый объект внутри массива.

Как узнать url иконки: [https://openweathermap.org/wea...](https://openweathermap.org/weather-conditions#How-to-get-icon-URL)

- в нижней части добавить необходимую информацию через цикл. Вам понадобится каждый 8-й объект, т.к в ответе приходит погода на каждые 3 часа (8 раз в сутки), а нам нужна погода 1 раз в сутки.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./task 16.4.css">
    <script src="./task 16.4.js"></script>
    <title>Document</title>
</head>
<body>
  <div class="weather-widget">
    <div class="current-weather">
      <h2 id="city"></h2>
      <p id="date"></p>
      <p class="temperature"></p>
      <p class="description"></p>
    </div>
    <div class="forecast">
      <h2>5-Day Forecast</h2>
      <div class="forecast-days"></div>
    </div>
  </div>
</body>
</html>


* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}


/* Стили для всего виджета */
.weather-widget {
  padding: 20px;
  border: 1px solid rgb(1, 231, 231);
}

/* Стили для текущей погоды */
.current-weather {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 100px;
  height: 200px;
  margin-bottom: 20px;
  background-color: aqua;
}
.current-weather #city{
position: relative;
left: 5%;
bottom: 22%;
height: 100px;
width: 200px;
}
.current-weather #date{
   padding-right: 100px;
   position: relative;
   right: 27%;
   bottom: 30%;
  }
.current-weather .temperature {
  font-size: 50px;
  font-weight: bold;
  color: #000000;
  padding-top: 50px;
  position: relative;
  right: 18%;
  bottom: 30%;
}

.current-weather .description {
  font-size: 24px;
  color: #666666;
  position: relative;
  left: -5%;
  bottom: 39%;
}

/* Стили для прогнозов */
.forecast h2{
  display: flex;
  justify-content: center;
}



.forecast {
  display: flex;
  flex-direction: column;
  justify-content: space-between;  
}

.forecast-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 1px solid rgb(1, 231, 231);
  margin-left: 100px;
  margin-right: 100px;
}

.forecast-item .date {
  font-size: 24px;
  font-weight: bold;
  color: #000000;
  padding-right: 50%;
}

.forecast-item .temperature {
  display: flex;
  font-size: 24px;
  color: #666666;
  padding-left: 50%;
}
.forecast-item img{
  display: flex;
  align-items: center;
}
.forecast-item .description {
  font-size: 18px;
  color: #666666;
}

/* Стили для иконок погоды */
.weather-icon {
  width: 50px;
  height: 50px;
  margin-bottom: 10px;
  background-repeat: no-repeat;
  background-size: contain;
}

.weather-icon.sun {
  background-image: url('https://yourdomain.com/01d.png');
}

.weather-icon.cloud {
  background-image: url('https://yourdomain.com/03d.png');
}

.weather-icon.rain {
  background-image: url('https://yourdomain.com/09d.png');
}

.weather-icon.thunderstorm {
  background-image: url('https://yourdomain.com/11d.png');
}

.weather-icon.snow {
  background-image: url('https://yourdomain.com/13d.png');
}

.weather-icon.fog {
  background-image: url('https://yourdomain.com/50d.png');
}


fetch(`https://api.openweathermap.org/data/2.5/forecast?q=Minsk&appid=a94d0a5ac08570add4b47b8da933f247`)
  .then(response => {
    console.log(response);
  })
  .catch(error => {
    console.error(error);
  });


const city = "Minsk";
const units = "metric";
const apiKey = "a94d0a5ac08570add4b47b8da933f247";

const url = `https://api.openweathermap.org/data/2.5/forecast?q=${city}&units=${units}&appid=${apiKey}`;

const currentDate = new Date().toLocaleDateString();

fetch(url)
  .then(response => {
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
    // добавляем данные в HTML разметку
    document.getElementById("city").textContent = `${data.city.name}, ${data.city.country}`;
    document.getElementById("date").textContent = currentDate;

    // получаем данные о текущей погоде из первого элемента массива "list"
    const currentWeather = data.list[0];
    const currentTemperature = Math.round(currentWeather.main.temp);
    const currentDescription = currentWeather.weather[0].description;

    // добавляем данные о текущей погоде на страницу
    document.querySelector(".current-weather .temperature").textContent = `${currentTemperature} °C`;
    document.querySelector(".current-weather .description").textContent = currentDescription;

    // получаем список прогнозов на каждый день
    const forecasts = data.list.filter((item, index) => {
      return index % 8 === 0;
      
    });

    // добавляем прогнозы на страницу
    const forecastContainer = document.querySelector(".forecast");
    forecasts.forEach(forecast => {

      const date = new Date(forecast.dt_txt).toLocaleDateString();
      const temperature = Math.round(forecast.main.temp);
      const description = forecast.weather[0].description;
      const windSpeed = forecast.wind.speed;
      const iconCode = forecast.weather[0].icon;
      const iconUrl = `http://openweathermap.org/img/w/${iconCode}.png`;
      const iconElement = document.createElement("img");
      iconElement.setAttribute("src", iconUrl);
      iconElement.setAttribute("alt", forecast.weather[0].description);


      const forecastItem = document.createElement("div");
      forecastItem.classList.add("forecast-item");

      const dateElement = document.createElement("div");
      dateElement.classList.add("date");
      dateElement.textContent = date;

      const temperatureElement = document.createElement("div");
      temperatureElement.classList.add("temperature");
      temperatureElement.textContent = `${temperature} °C`;

      const descriptionElement = document.createElement("div");
      descriptionElement.classList.add("description");
      descriptionElement.textContent = description;

      const windElement = document.createElement("div");
      windElement.classList.add("wind");
      windElement.textContent = `${windSpeed} m/s`;

      forecastItem.appendChild(iconElement);
      forecastItem.appendChild(dateElement);
      forecastItem.appendChild(temperatureElement);
      forecastItem.appendChild(descriptionElement);
      forecastItem.appendChild(windElement);
      forecastContainer.appendChild(forecastItem);
    });
  })
  .catch(error => {
    console.error(error);
  });